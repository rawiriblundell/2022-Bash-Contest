#!/usr/bin/env bash

#------------------------------------------------------------------------------
# Path         - /usr/bin/tbpm
# GitHub       - https://github.com/The-Repo-Club/
# Author       - The-Repo-Club [wayne6324@gmail.com]
# Start On     - Sun 12 Dec 13:39:12 GMT 2021
# Modified On  - Sun 12 Dec 13:39:12 GMT 2021
#------------------------------------------------------------------------------

# More about colors at Arch Wiki
# https://wiki.archlinux.org/index.php/Color_Bash_Prompt
#
# Don't use double quotes here!
# Text attributes
declare -r txtClean=$'\e[0m'      # All attributes off
declare -r txtBold=$'\e[1m'       # Or bright, depend on your terminal
declare -r txtUScore=$'\e[4m'     # Underscore
declare -r txtHide=$'\e[8m'       # Concealed, very useful here...

# Foreground colors only. Someone may miss backgroud colors.
declare -r colBlack=$'\e[30m'
declare -r colRed=$'\e[31m'
declare -r colGreen=$'\e[32m'
declare -r colYello=$'\e[33m'
declare -r colBlue=$'\e[34m'
declare -r colMagenta=$'\e[35m'
declare -r colArchBlue=$'\e[36m'  # Well, someone may call it Cyan
declare -r colWhite=$'\e[37m'

## Script metadata
tbpm_scriptname=${0##*/}
tbpm_version="2021.12.12"
tbpm_description="Terminal Based Password Manager"
tbpm_author="The-Repo-Club <wayne6324@gmail.com>"
tbpm_description_color="${colBlue}T${txtClean}erminal ${colBlue}B${txtClean}ased ${colBlue}P${txtClean}assword ${colBlue}M${txtClean}anager"
GPG_OPTS="--quiet --batch --use-agent"

readonly tbpm_scriptname tbpm_description tbpm_description_color tbpm_version tbpm_author

# Get the top level PID and setup a trap so that we can call die() within subshells
trap "exit 1" TERM
_self_pid="${$}"
export _self_pid

if [[ -z "$TBPM" ]]; then
    PASSWORD_STORE_DIR=$HOME/.tbpm
else
    PASSWORD_STORE_DIR=$TBPM
fi

#=== FUNCTION =================================================================
#        Name: msg
# Description: Print message with a green pretag if $quiet is not set.
# Parameter 1: Message to print.
#==============================================================================
# Provenance: makepkg
msg() {
    if [[ -t 0 ]]; then
        printf "${colGreen}==>${txtClean}${txtBold} %s${txtClean}\n" "${*}"
    else
        printf "==> %s\n" "${*}"
    fi
}

#=== FUNCTION =================================================================
#        Name: die
# Description: Print an error message and exit.
# Parameter 1: Message to print.
#==============================================================================
# Provenance: https://gist.github.com/rawiriblundell/2dab6903848f73641652a8e95e872dcb
die() {
    if [[ -t 0 ]]; then
        printf "${colRed}==> ERROR:${txtClean}${txtBold} %s${txtClean}\n" "${*}" >&2
    else
        printf "==> ERROR: %s\n" "${*}" >&2
    fi
  # Send a TERM signal to the top level PID, this is trapped and exit 1 is forced
  kill -s TERM "${_self_pid}"
}

#=== FUNCTION =================================================================
#        Name: confirm
# Description: Prompt and read an interactive yes/no response
#        Stops reading after one character, meaning only 'y' or 'Y' will return 0
#        Any other character, or an optional timeout (-t|--timeout) will return 1
# Options:
#        [-t|--timeout] (number of seconds).
#        When used, function returns 1 when the timeout is reached.
# Parameter 1: Message to print.
#==============================================================================
# Provenance: https://gist.github.com/rawiriblundell/7e8a26d8076ce09b6daa315389f822cd
confirm() {
    [[ -t 0 ]] || return 0
    local confirm_args
    case "${1}" in
        (-t|--timeout)
            confirm_args=( -t "${2}" -rn 1 -p )
            set -- "${@:3}"
        ;;
        (*)  confirm_args=( -rn 1 -p ) ;;
    esac
    
    # shellcheck disable=SC2162 # '-r' is provided by confirm_args[@]
    read "${confirm_args[@]}" "${*:-Continue} [y/N]? "
    printf -- '%s\n' ""
    case "${REPLY}" in
        ([yY]) return 0 ;;
        (*)    return 1 ;;
    esac
}

#=== FUNCTION =================================================================
#        Name: is_integer
# Description: Test whether a given var is an integer
#        Optional +/- specifiers are supported
# Parameter 1: Var to validate
#==============================================================================
is_integer() {
    case "${1#[-+]}" in 
        (''|*[!0-9]*) return 1 ;;
    esac
    return 0
}

#=== FUNCTION =================================================================
#        Name: validate_param_count
# Description: Test whether the number of given parameters is correct
# Parameter 1: Desired number of parameters
# Parameter 2: Actual number of parameters (usually "${#}")
#==============================================================================
validate_param_count() {
    local desired_count actual_count
    # Prevent irony
    (( "${#}" != 2 )) && die "Incorrect number of parameters to check"
    # Validate that our vars are actually integers
    is_integer "${desired_count}" || die "${desired_count} is not an integer"
    is_integer "${actual_count}" || die "${actual_count} is not an integer"
    # Finally, run the actual testing
    (( actual_count < desired_count )) && die "Not enough parameters supplied"
    (( actual_count > desired_count )) && die "Too many parameters supplied."
}

#=== FUNCTION =================================================================
#        Name: get_newest_commit_date
# Description: Get the latest commit timestamp for a given file
# Parameter 1: File to report on
#==============================================================================
get_newest_commit_date() {
    # Output in epoch time for easy sorting, followed by relative date
    git --no-pager log -1 --pretty=format:'%ct (%cr)' -- "${1:?No file specified}"
}

#=== FUNCTION =================================================================
#        Name: audit
# Description: audit and report on the ages of all contained password files
# Parameter 1: [all,pwds,subfolder,file,glob].  If blank, all .gpg files are processed.
#==============================================================================
audit() {
    (
        cd "${PASSWORD_STORE_DIR}" || exit 1
        local ls_filter fsobj fsobj_len printf_fmt col2_align passpath
        case "${1}" in
            (all)       ls_filter='.' ;;
            (''|pwds)   ls_filter='*.gpg' ;;
            (*)
                # shellcheck disable=SC2068 # We want word splitting here
                for fsobj in ${@}; do
                    fsobj="${fsobj#/}"                               # Strip any leading slash
                    [[ -f "${fsobj}.gpg" ]] && fsobj="${fsobj}.gpg"  # Auto-append .gpg extension
                    ls_filter="${ls_filter} ${fsobj}"
                done
            ;;
        esac

        # Find the length of the longest filename, this informs our output format
        fsobj_len=0
        # shellcheck disable=SC2086 # We need ls_filter to word split
        while read -r; do
            (( "${#REPLY}" > fsobj_len )) && fsobj_len="${#REPLY}"
        done < <(git ls-files ${ls_filter:-.})

        # Adjust output based on (longest filename + padding + date output) vs terminal width...
        if (( (fsobj_len + 4 + 36) < "${COLUMNS:-$(tput cols)}" )); then
            col2_align="$(( fsobj_len + 4 ))"
            printf_fmt="%-${col2_align}s %s\\n"
            printf -- "%-${col2_align}s %s\\n" "Filename" "Last Commit"
        else
            printf_fmt='\nFilename: %s\nLast Commit: %s\n'
        fi

        # Loop through our files
        # shellcheck disable=SC2086 # We need ls_filter to word split
        while read -r; do
            # Strip the .gpg extension in the output
            case "${REPLY}" in
                (*.gpg) passpath="${REPLY/.gpg/}" ;;
                (*)     passpath="${REPLY}" ;;
            esac

            # shellcheck disable=SC2059
            printf -- "${printf_fmt}" "${passpath}" "$(get_newest_commit_date "${REPLY}")"
        done < <(git ls-files ${ls_filter:-.})
    )
}

#=== FUNCTION =================================================================
#        Name: initialize
# Description: Initialize the password manager.
# Parameter 1: GPG key.
#==============================================================================
initialize() {
    local gpg_key=

    mkdir -p "${PASSWORD_STORE_DIR}" || die "Failed to create ${PASSWORD_STORE_DIR}"
    validate_param_count 2 "${#}"
    shift

    local key="${1}"
    while read -r gpg_id; do
        if [[ "$gpg_id" = "$key" ]]; then
            gpg_key="${gpg_id}"
        fi
    done < <(gpg --list-keys)

    [[ -z "${gpg_key}" ]] && die "valid GPG does not exist!"

    echo "${gpg_key}" > "${PASSWORD_STORE_DIR}"/.gpg_key
    msg "GPG '${gpg_key}' has been saved to ${PASSWORD_STORE_DIR}/.gpg_key"

    exit 0
}

#=== FUNCTION =================================================================
#        Name: write
# Description: Write a password to the password manager.
# Parameter 1: the file name without .gpg.
# Parameter 2: the password for ther file.
#==============================================================================
write() {
    validate_param_count 3 "${#}"
    shift

    local passfile="${1}"
    local password="${2}"
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${PASSWORD_STORE_DIR}/${passfile}.gpg" ]]; then
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            die "That password file already exists."
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            gpg_key=$(cat "${PASSWORD_STORE_DIR}"/.gpg_key)
            echo -e "${password}" > /tmp/"${passfile_temp}"
            gpg "${GPG_OPTS} --output ${PASSWORD_STORE_DIR}/${passfile}.gpg --encrypt --recipient ${gpg_key} /tmp/${passfile_temp}"
            rm -f "/tmp/${passfile_temp}"
            msg "Password '${password}' has been saved to ${PASSWORD_STORE_DIR}/${passfile}.gpg"
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: print
# Description: Print a password from the password manager.
# Parameter 1: the file name without .gpg.
#==============================================================================
print() {
    case "${3}" in
        (-c|--copy) shift; copy "${@}" ;;
    esac

    validate_param_count 2 "${#}"
    shift

    local passfile=${1%%-*}
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${PASSWORD_STORE_DIR}/${passfile}.gpg" ]]; then
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            gpg "${GPG_OPTS} --output /tmp/${passfile_temp} --decrypt ${PASSWORD_STORE_DIR}/${passfile}.gpg"
            password=$(<"/tmp/${passfile_temp}")
            printf -- '%s: %s\n' "${passfile}" "${password}"
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            die "That password file does not exists."
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: copy
# Description: Copy a command from the print options.
# Parameter 1: the file name without .gpg.
#==============================================================================
copy() {
    validate_param_count 2 "${#}"

    local passfile="${1%%-*}"
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${PASSWORD_STORE_DIR}/${passfile}.gpg" ]]; then
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            gpg "${GPG_OPTS} --output /tmp/${passfile_temp} --decrypt ${PASSWORD_STORE_DIR}/${passfile}.gpg"
            password=$(<"/tmp/${passfile_temp}")
            if command -v clipmenu-ctl &> /dev/null; then
                clipmenu-ctl disable
                if [[ "$(clipmenu-ctl status)" = "disabled" ]]; then
                    printf "%s\n" "${password%%$'\n'*}" | xclip -selection clipboard
                fi
                clipmenu-ctl enable
            else
                printf "%s\n" "${password%%$'\n'*}" | xclip -selection clipboard
            fi
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            die "That password file does not exists."
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: list
# Description: List the passwords from the password manager.
#==============================================================================
list() {
    validate_param_count 1 "${#}"
    shift

    if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
        printf "%s\n" "${tbpm_description_color}"
        while read -r; do
            if [[ ! "$REPLY" = "${PASSWORD_STORE_DIR}" ]]; then
                echo "${REPLY::-4}"
            fi
        done < <(tree -N -l --noreport --prune --matchdirs --ignore-case "${PASSWORD_STORE_DIR}")
    else
        die "valid GPG does not exist!"
    fi
    exit
}

#=== FUNCTION =================================================================
#        Name: edit
# Description: Edit a password from the password manager.
#==============================================================================
edit() {
    validate_param_count 2 "${#}"
    shift

    local passfile="${1}"
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${PASSWORD_STORE_DIR}/${passfile}.gpg" ]]; then
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            gpg "${GPG_OPTS} --output /tmp/${passfile_temp} --decrypt ${PASSWORD_STORE_DIR}/${passfile}.gpg"
            ${VISUAL:-vim} "/tmp/$passfile_temp"
            password=$(<"/tmp/${passfile_temp}")
	        [[ -f "/tmp/$passfile_temp" ]] || die "New password not saved."
            gpg "-d -o - ${GPG_OPTS}" "${PASSWORD_STORE_DIR}/${passfile}.gpg" 2>/dev/null | 
                diff - "/tmp/$passfile_temp" &>/dev/null && die "Password unchanged."
            gpg_key=$(<"${PASSWORD_STORE_DIR}"/.gpg_key)
            while ! gpg "--yes ${GPG_OPTS} --output ${PASSWORD_STORE_DIR}/${passfile}.gpg --encrypt --recipient ${gpg_key} /tmp/${passfile_temp}"; do
                confirm "GPG encryption failed. Would you like to try again"
            done
            rm -f "/tmp/${passfile_temp}"
            msg "${VISUAL:-vim}: Password '${password%%$'\n'*}' has been saved to ${PASSWORD_STORE_DIR}/${passfile}.gpg"
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            die "That password file does not exists."
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: generate
# Description: Generate a password to the password manager.
# Parameter 1: the file name without .gpg.
# Parameter 2: password leanth.
#==============================================================================
generate() {
    validate_param_count 3 "${#}"
    shift

    local passfile="${1}"
    local length="${2}"
    is_integer "${length}" || die "password length \"$length\" must be a number."
	(( length > 0 )) || die "password length must be greater than zero."
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${PASSWORD_STORE_DIR}/${passfile}.gpg" ]]; then
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            die "That password file already exists."
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${PASSWORD_STORE_DIR}"/.gpg_key ]]; then
            gpg_key=$(<"${PASSWORD_STORE_DIR}"/.gpg_key)
            read -r -n "${length}" password < <(LC_ALL=C tr -dc "[:punct:][:alnum:]" < /dev/urandom)
            (( "${#password}" == length )) || die "Could not generate password from /dev/urandom."

            echo -e "${password}" > "/tmp/${passfile_temp}"
            gpg "${GPG_OPTS} --output ${PASSWORD_STORE_DIR}/${passfile}.gpg --encrypt --recipient ${gpg_key} /tmp/${passfile_temp}"
            rm -f "/tmp/${passfile_temp}"
            msg "Password '${password}' has been saved to ${PASSWORD_STORE_DIR}/${passfile}.gpg"
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: usage
# Description: Prints the usage.
#==============================================================================
usage() {
cat << EOF
    ${tbpm_description_color} - v${tbpm_version}

    Usage:
      "${tbpm_scriptname}" <password>...
      "${tbpm_scriptname}" [options] [<password>]...

    Options:
        -a, --audit                 Audit and report on aged passwords.
        -h, --help                  Display help.
        -w, --write                 Write a password to the database.
        -g, --generate              Generate a password.
        -e, --edit                  Edit a password.
        -d, --delete                Delete a password.
        -p, --print                 Print saved password data to the terminal.
        -l, --list                  List the saved password in a tree format.
        -b, --backup                Backup passwords to a tar file.
        -r, --restore               Restore password from a tar file.
        -v, --version               Print version information and exits.

    --print Options:
        -c, --copy                  Copy a printed password using xclip.

EOF
      exit 0
}

#=== FUNCTION =================================================================
#        Name: version
# Description: Prints version information.
#==============================================================================
version() {
cat << EOF
     _________   ______    ______    ____    ____
    |  _   _  | |_   _ \  |_   __ \ |_   \  /   _|
    |_/ | | \_|   | |_) |   | |__) |  |   \/   |
        | |       |  __'.   |  ___/   | |\  /| |
       _| |_     _| |__) | _| |_     _| |_\/_| |_
      |_____|   |_______/ |_____|   |_____||_____|

    ${tbpm_description_color} - v${tbpm_version}

    This program may be freely redistributed under
    the terms of the GNU General Public License v3.0.

    ${tbpm_author}

EOF
    exit 0
}

#=== FUNCTION =================================================================
#        Name: main
# Description: Main script logic
#==============================================================================
main() {
    (( "${#}" == 0 )) && usage

    # Fail early if we don't have the commands that we need
    for cmd in git gpg; do
        ! command -v "${cmd}" >/dev/null 2>&1 && failed_cmds=",${cmd}"
    done

    if (( "${#failed_cmds/,/}" > 0 )); then
        die "The following commands were required but not found: ${failed_cmds/,/}"
    fi

    while [[ "${1}" ]]; do
        case "${1}" in
            (-a|--audit)    audit "${1}" ;;
            (-i|--init)     initialize "${@}"; shift 1 ;;
            (-w|--write)    write "${@}"; shift 1 ;;
            (-p|--print)    print "${@}"; shift 1 ;;
            (-e|--edit)     edit "${@}"; shift 1 ;;
            (-l|--list)     list "${@}"; shift 1 ;;
            (-g|--generate) generate "${@}"; shift 1 ;;
            (-h|--help|-\?) usage; shift 1 ;;
            (-v|--version)  version; shift 1 ;;
            (-*)
                die "Unknown option: ${1}"
                usage
            ;;
            (*)             usage ;;
        esac
    done
}

# Call main()
main "${@}"

# It's good habit to always exit 0 at the end of a script
exit 0

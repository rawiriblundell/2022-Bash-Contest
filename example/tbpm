#!/usr/bin/env bash

#------------------------------------------------------------------------------
# Path         - /usr/bin/tbpm
# GitHub       - https://github.com/The-Repo-Club/
# Author       - The-Repo-Club [wayne6324@gmail.com]
# Start On     - Sun 12 Dec 13:39:12 GMT 2021
# Modified On  - Sun 12 Dec 13:39:12 GMT 2021
#------------------------------------------------------------------------------

# More about colors at Arch Wiki
# https://wiki.archlinux.org/index.php/Color_Bash_Prompt
#
# Don't use double quotes here!
# Text attributes
declare -r txtClean=$'\e[0m'      # All attributes off
declare -r txtBold=$'\e[1m'       # Or bright, depend on your terminal
declare -r txtUScore=$'\e[4m'     # Underscore
declare -r txtHide=$'\e[8m'       # Concealed, very useful here...

# Foreground colors only. Someone may miss backgroud colors.
declare -r colBlack=$'\e[30m'
declare -r colRed=$'\e[31m'
declare -r colGreen=$'\e[32m'
declare -r colYello=$'\e[33m'
declare -r colBlue=$'\e[34m'
declare -r colMagenta=$'\e[35m'
declare -r colArchBlue=$'\e[36m'  # Well, someone may call it Cyan
declare -r colWhite=$'\e[37m'

## Script metadata
tbpm_scriptname=${0##*/}
tbpm_version="2021.12.12"
tbpm_description="Terminal Based Password Manager"
tbpm_author="The-Repo-Club <wayne6324@gmail.com>"
tbpm_description_color="${colBlue}T${txtClean}erminal ${colBlue}B${txtClean}ased ${colBlue}P${txtClean}assword ${colBlue}M${txtClean}anager"
GPG_OPTS="--quiet --batch --use-agent"

readonly tbpm_scriptname tbpm_description tbpm_description_color tbpm_version tbpm_author

# Get the top level PID and setup a trap so that we can call die() within subshells
trap "exit 1" TERM
_self_pid="${$}"
export _self_pid

if [[ -z "$TBPM" ]]; then
    pass_dir=$HOME/.tbpm
else
    pass_dir=$TBPM
fi

#=== FUNCTION =================================================================
#        Name: msg
# Description: Print message with a green pretag if $quiet is not set.
# Parameter 1: Message to print.
#==============================================================================
# Provenance: makepkg
msg() {
    if [ -t 0 ]; then
        printf "${colGreen}==>${txtClean}${txtBold} %s${txtClean}\n" "${*}"
    else
        printf "==> %s\n" "${*}"
    fi
}

#=== FUNCTION =================================================================
#        Name: die
# Description: Print an error message and exit.
# Parameter 1: Message to print.
#==============================================================================
# Provenance: https://gist.github.com/rawiriblundell/2dab6903848f73641652a8e95e872dcb
die() {
    if [ -t 0 ]; then
        printf "${colRed}==> ERROR:${txtClean}${txtBold} %s${txtClean}\n" "${*}" >&2
    else
        printf "==> ERROR: %s\n" "${*}" >&2
    fi
  # Send a TERM signal to the top level PID, this is trapped and exit 1 is forced
  kill -s TERM "${_self_pid}"
}

#=== FUNCTION =================================================================
#        Name: confirm
# Description: Prompt and read an interactive yes/no response
#        Stops reading after one character, meaning only 'y' or 'Y' will return 0
#        Any other character, or an optional timeout (-t|--timeout) will return 1
# Options:
#        [-t|--timeout] (number of seconds).
#        When used, function returns 1 when the timeout is reached.
# Parameter 1: Message to print.
#==============================================================================
# Provenance: https://gist.github.com/rawiriblundell/7e8a26d8076ce09b6daa315389f822cd
confirm() {
    [[ -t 0 ]] || return 0
    local confirm_args
    case "${1}" in
        (-t|--timeout)
            confirm_args=( -t "${2}" -rn 1 -p )
            set -- "${@:3}"
        ;;
        (*)  confirm_args=( -rn 1 -p ) ;;
    esac
    
    # shellcheck disable=SC2162 # '-r' is provided by confirm_args[@]
    read "${confirm_args[@]}" "${*:-Continue} [y/N]? "
    printf -- '%s\n' ""
    case "${REPLY}" in
        ([yY]) return 0 ;;
        (*)    return 1 ;;
    esac
}

#=== FUNCTION =================================================================
#        Name: is_integer
# Description: Test whether a given var is an integer
#        Optional +/- specifiers are supported
# Parameter 1: Var to validate
#==============================================================================
is_integer() {
    case "${1#[-+]}" in 
        (''|*[!0-9]*) return 1 ;;
    esac
    return 0
}

#=== FUNCTION =================================================================
#        Name: validate_param_count
# Description: Test whether the number of given parameters is correct
# Parameter 1: Desired number of parameters
# Parameter 2: Actual number of parameters (usually "${#}")
#==============================================================================
validate_param_count() {
    local desired_count actual_count
    # Prevent irony
    (( "${#}" != 2 )) && die "Incorrect number of parameters to check"
    # Validate that our vars are actually integers
    is_integer "${desired_count}" || die "${desired_count} is not an integer"
    is_integer "${actual_count}" || die "${actual_count} is not an integer"
    # Finally, run the actual testing
    (( actual_count < desired_count )) && die "Not enough parameters supplied"
    (( actual_count > desired_count )) && die "Too many parameters supplied."
}

#=== FUNCTION =================================================================
#        Name: initialize
# Description: Initialize the password manager.
# Parameter 1: GPG key.
#==============================================================================
initialize() {
    local gpg_key=

    mkdir -p "${pass_dir}" || die "Failed to create ${pass_dir}"
    validate_param_count 2 "${#}"
    shift

    local key=$1
    while read -r gpg_id; do
        if [[ "$gpg_id" == "$key" ]]; then
            gpg_key=$gpg_id
        fi
    done < <( gpg --list-keys )

    [ -z "${gpg_key}" ] && die "valid GPG does not exist!"

    echo "${gpg_key}" > "${pass_dir}"/.gpg_key
    msg "GPG '${gpg_key}' has been saved to ${pass_dir}/.gpg_key"

    exit 0
}

#=== FUNCTION =================================================================
#        Name: write
# Description: Write a password to the password manager.
# Parameter 1: the file name without .gpg.
# Parameter 2: the password for ther file.
#==============================================================================

write() {
    validate_param_count 3 "${#}"
    shift

    local passfile=$1
    local password=$2
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${pass_dir}/${passfile}.gpg" ]]; then
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            die "That password file already exists."
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            gpg_key=$(cat "${pass_dir}"/.gpg_key)
            echo -e "${password}" > /tmp/"${passfile_temp}"
            gpg "${GPG_OPTS} --output ${pass_dir}/${passfile}.gpg --encrypt --recipient ${gpg_key} /tmp/${passfile_temp}"
            rm -f "/tmp/${passfile_temp}"
            msg "Password '${password}' has been saved to ${pass_dir}/${passfile}.gpg"
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: print
# Description: Print a password from the password manager.
# Parameter 1: the file name without .gpg.
#==============================================================================

print() {
    case $3 in
        (-c|--copy) shift; copy "${@}" ;;
    esac

    validate_param_count 2 "${#}"
    shift

    local passfile=${1%%-*}
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${pass_dir}/${passfile}.gpg" ]]; then
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            gpg "${GPG_OPTS} --output /tmp/${passfile_temp} --decrypt ${pass_dir}/${passfile}.gpg"
            password=$(<"/tmp/${passfile_temp}")
            printf -- '%s: %s\n' "${passfile}" "${password}"
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            die "That password file does not exists."
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: copy
# Description: Copy a command from the print options.
# Parameter 1: the file name without .gpg.
#==============================================================================

copy() {
    validate_param_count 2 "${#}"

    local passfile=${1%%-*}
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${pass_dir}/${passfile}.gpg" ]]; then
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            gpg "${GPG_OPTS} --output /tmp/${passfile_temp} --decrypt ${pass_dir}/${passfile}.gpg"
            password=$(<"/tmp/${passfile_temp}")
            if command -v clipmenu-ctl &> /dev/null; then
                clipmenu-ctl disable
                if [ "$(clipmenu-ctl status)" == "disabled" ]; then
                    printf "%s\n" "${password%%$'\n'*}" | xclip -selection clipboard
                fi
                clipmenu-ctl enable
            else
                printf "%s\n" "${password%%$'\n'*}" | xclip -selection clipboard
            fi
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            die "That password file does not exists."
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: list
# Description: List the passwords from the password manager.
#==============================================================================

list() {
    validate_param_count 1 "${#}"
    shift

    if [[ -f "${pass_dir}"/.gpg_key ]]; then
        printf "%s\n" "${tbpm_description_color}"
        while read -r; do
            if [[ ! "$REPLY" == "${pass_dir}" ]]; then
                echo "${REPLY::-4}"
            fi
        done < <( tree -N -l --noreport --prune --matchdirs --ignore-case "${pass_dir}" )
    else
        die "valid GPG does not exist!"
    fi
    exit
}

#=== FUNCTION =================================================================
#        Name: edit
# Description: Edit a password from the password manager.
#==============================================================================

edit() {
    validate_param_count 2 "${#}"
    shift

    local passfile=$1
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${pass_dir}/${passfile}.gpg" ]]; then
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            gpg "${GPG_OPTS} --output /tmp/${passfile_temp} --decrypt ${pass_dir}/${passfile}.gpg"
            ${VISUAL:-vim} "/tmp/$passfile_temp"
            password=$(<"/tmp/${passfile_temp}")
	        [[ -f "/tmp/$passfile_temp" ]] || die "New password not saved."
            gpg "-d -o - ${GPG_OPTS}" "${pass_dir}/${passfile}.gpg" 2>/dev/null | 
                diff - "/tmp/$passfile_temp" &>/dev/null && die "Password unchanged."
            gpg_key=$(<"${pass_dir}"/.gpg_key)
            while ! gpg "--yes ${GPG_OPTS} --output ${pass_dir}/${passfile}.gpg --encrypt --recipient ${gpg_key} /tmp/${passfile_temp}"; do
                confirm "GPG encryption failed. Would you like to try again"
            done
            rm -f "/tmp/${passfile_temp}"
            msg "${VISUAL:-vim}: Password '${password%%$'\n'*}' has been saved to ${pass_dir}/${passfile}.gpg"
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            die "That password file does not exists."
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: generate
# Description: Generate a password to the password manager.
# Parameter 1: the file name without .gpg.
# Parameter 2: password leanth.
#==============================================================================

generate() {
    validate_param_count 3 "${#}"
    shift

    local passfile=$1
    local length=$2
    [[ $length =~ ^[0-9]+$ ]] || die "password length \"$length\" must be a number."
	[[ $length -gt 0 ]] || die "password length must be greater than zero."
    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"

    if [[ -f "${pass_dir}/${passfile}.gpg" ]]; then
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            die "That password file already exists."
        else
            die "valid GPG does not exist!"
        fi
    else
        if [[ -f "${pass_dir}"/.gpg_key ]]; then
            gpg_key=$(<"${pass_dir}"/.gpg_key)
            read -r -n "$length" password < <(LC_ALL=C tr -dc "[:punct:][:alnum:]" < /dev/urandom)
            [[ ${#password} -eq $length ]] || die "Could not generate password from /dev/urandom."

            echo -e "${password}" > "/tmp/${passfile_temp}"
            gpg "${GPG_OPTS} --output ${pass_dir}/${passfile}.gpg --encrypt --recipient ${gpg_key} /tmp/${passfile_temp}"
            rm -f "/tmp/${passfile_temp}"
            msg "Password '${password}' has been saved to ${pass_dir}/${passfile}.gpg"
        else
            die "valid GPG does not exist!"
        fi
    fi
    exit 0
}

#=== FUNCTION =================================================================
#        Name: usage
# Description: Prints the usage.
#==============================================================================

usage() {
cat << EOF
    ${tbpm_description_color} - v${tbpm_version}

    Usage:
      "${tbpm_scriptname}" <password>...
      "${tbpm_scriptname}" [options] [<password>]...

    Options:
        -h, --help                  Display help.
        -w, --write                 Wite a password to the database.
        -g, --generate              Generate a password.
        -e, --edit                  Edit a password.
        -d, --delete                Delete a password.
        -p, --print                 Print saved password data to the terminal.
        -l, --list                  List the saved password in a tree format.
        -b, --backup                Backup passwords to a tar file.
        -r, --restore               Restore password from a tar file.
        -v, --version               Print version information and exits.

    --print Options:
        -c, --copy                  Copy a printed password using xclip.

EOF
      exit 0
}

#=== FUNCTION =================================================================
#        Name: version
# Description: Prints version information.
#==============================================================================

version() {
cat << EOF
     _________   ______    ______    ____    ____
    |  _   _  | |_   _ \  |_   __ \ |_   \  /   _|
    |_/ | | \_|   | |_) |   | |__) |  |   \/   |
        | |       |  __'.   |  ___/   | |\  /| |
       _| |_     _| |__) | _| |_     _| |_\/_| |_
      |_____|   |_______/ |_____|   |_____||_____|

    ${tbpm_description_color} - v${tbpm_version}

    This program may be freely redistributed under
    the terms of the GNU General Public License v3.0.

    ${tbpm_author}

EOF
    exit 0
}

main() {
    (( "${#}" == 0 )) && usage

    while [ "${1}" ]; do
        case "${1}" in
            (-i|--init)     initialize "${@}"; shift 1 ;;
            (-w|--write)    write "${@}"; shift 1 ;;
            (-p|--print)    print "${@}"; shift 1 ;;
            (-e|--edit)     edit "${@}"; shift 1 ;;
            (-l|--list)     list "${@}"; shift 1 ;;
            (-g|--generate) generate "${@}"; shift 1 ;;
            (-h|--help|-\?) usage; shift 1 ;;
            (-v|--version)  version; shift 1 ;;
            (-*)
                die "Unknown option: ${1}"
                usage
            ;;
            (*)             usage ;;
        esac
    done
}

main "${@}"

exit 0
